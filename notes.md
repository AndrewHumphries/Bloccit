BASIC RAILS APP CHECKPOINT

First, had to create a new Rails application — within the command line: 
## $ cd [directory where you want the app]
## $ rails new [name of program] -d postgresql -T
    A) -d indicates the database platform that it will default to;
    B) -T option specifies app will NOT use standard unit test packages. Don't need them because I'm going to write RSpec. 

  Next, change the README from a .rdoc to a .md (markdown)
  ## $ mv README.rdoc REDME.md

  Next, configure the database. When we ran "rails new", we got a database.yml file. A yammel file "specifies the configuration of the databases that will interact with your app."

  Remove the lines in the yammel related to a username/password; we'll just be using the default database user
  Then, back in terminal, create the database:
  ## $rake db:create

  STATIC PAGES CHECKPOINT

  Rails works on a MODEL — VIEW — CONTROLLER Format. View is the equivalent to a webpage; controller determines what view should be shown. 

  When you create a controller, you create the associated views as well. To do this, just get into your app directory and: 
  ## $ rails g controller welcome index about
  Created a welcome controller and two corresponding views (index & about)

  If you open up the welcome_controller, you're going to see two automatically created methods: index and about. These are methods that invoke the view, so you have to name them after the corresponding view. 

  If you open up the views, you see placeholders:

#<h1>Welcome#index</h1>
#<p>Find me in app/views/welcome/index.html.erb</p>

When we ran the controller generator, another thing happened — it created code in bloccit/config/routes.rb. If you open that up, you'll see:

Bloccit::Application.routes.draw do
  get "welcome/index"

  get "welcome/about"
end

This is basic HTTP protocol to create "get" routes for index/about pages. HTTP protocol has four primary actions: GET, POST, PUT and DELETE. GET allows a user to retrieve the information identified by the URL. Without a GET action in Routes, the user would not be able to see the HTML in the view. We're going to add one route: 

Bloccit::Application.routes.draw do
  get "welcome/index"

  get "welcome/about"

  root to: 'welcome#index'
end

The root method declares the default page (so where a user goes when typing in home page URL). 
Also need to delete the default Rails page: 
## $ rm public/index.html

Can always check our routes by typing rake routes from command line:

$ rake routes
welcome_index GET    /welcome/index(.:format)  welcome#index
welcome_about GET    /welcome/about(.:format)  welcome#about
         root        /                         welcome#index

First column = route name. 
Second column = associated HTTP action. 
Third column = URL pattern. 
Fourth column = route destination (controller & associated view)

HTML CHECKPOINT

HTML = code that a browser can interpret/display as a webpage. This is basic HTML (from Index View): 
## <h1>Welcome#index</h1>
## <p>Find me in app/views/welcome/index.html.erb</p>

HTML is the syntax between the < >. The formats (like h1) specify how it's rendered. What's in the middle is what's going to be displayed.

The views have html.erb extensions — that means we can code with both HTML & Ruby. 

Alright, let's update application.html.erb. This is part of the views/layouts directory, and it's invoked as a container for every view in the application & contains information that is needed on every page of the application. (So, like, the title bar could go here...?) What's basically happening:

1. A view is requested;
2. The controller corresponding to that view invokes 'application.html.erb';
3. application.html.erb invokes the appropriate view via yield; 
4. The complate web page is rendered & returned. 

So, the code we stick into application,html.erb, it's meant to contain all the other HTML code that could be rendered by views in the app. 

<!DOCTYPE html>
<html>
<head>
  <title>Bloccit</title>
  <%= stylesheet_link_tag    "application", :media => "all" %>
  <%= javascript_include_tag "application" %>
  <%= csrf_meta_tags %>
</head>
<body>

    <ul>
        <li><%= link_to "Home", welcome_index_path %></li>
        <li><%= link_to "About", welcome_about_path %></li>
    </ul>

    <%= yield %>

</body>
</html>

Check that yield method. Presence of the % says "THIS IS RUBY SYNTAX. USE IT!" If it has the =, it's going to print the result of the code to the screen (it'll render it as HTML). A couple of other things: 
<ul> creates a bulleted (unordered) list — <li> denotes a list item. 
link_to is a method available in rails, and it returns a 'qualified HTML hyper link' (an anchor tag). So:

link_to "Home", welcome_index_path will render <a href="/welcome/index">Home</a> It's got two arguments — a string, which will be the display name, and "welcome_index_path", which is actually ANOTHER Rails method, generated by the routes file. Adding _path to a route name lets Rails read it as /welcome/index. 

CSS CHECKPOINT

CSS = Cascading Style Sheets. It's syntax used to style and position HTML elements on a web page. 

CSS is made of selectors, properties and values. 

Selector designates the HTML tag to be modified. 

h1 {
  color: red;
}

This is a piece of code we modified in welcome.css.scss (another thing the rails g controller created for us); every controller has a corresponding style sheet. So, in that piece of CSS, I selected all h1 elements. h1 { } is the selector. 

What if I only want to style specific h1's? id selectors and class selectors. 

The simple one, the one I just did — that's the tag selector. HTML element followed by {}. An ID selector is when I want to do a unique sytling so:

h1 {
  color: red;
}

p#index-title {
  text-align: center;
  font-size: 15px;
  color: blue;
}

If I add this to my style sheet, and add this to my index view:

<h1>Welcome to Bloccit</h1>
<p id="index-title">This is the home page for Bloccit.</p>

Then I've basically said, find anything with the id "index-title" and style it in this specific way. Or, I could create a class:

.posts {
  border: solid;
  margin: 5px;
  padding: 5px;
  height: 200px;
}

So, now add to the index view: 

<h1>Welcome to Bloccit</h1>
<p id="index-title">This is the home page for Bloccit.</p>

<div class="posts">Post 1 goes here.</div>
<div class="posts">Post 2 goes here.</div>

Anything in the posts class gets that styling. Everything in that post class css is based on the box model (margin, border, padding, content). Every HTML element has a box model. 

Since CSS is sort of specialized, lots of people download and institute a framework (like Twitter Bootstrap).It provides layouts, forms, buttons, icons, Javascript functions, & more. Install it by adding it to the gem file:

group :assets do
  gem 'sass-rails',   '~> 3.2.3'
  gem 'coffee-rails', '~> 3.2.1'
  gem 'bootstrap-sass', '~> 2.3.1.0'
  gem 'uglifier', '>= 1.0.3'
end

Then run the bundle:

## $ bundle install

Then rename application .css to application.css.scss and remove everything in there. Replace it with:
@import "bootstrap";

Almost all of my CSS will go in the application.css.scss, not the controller-specific. Now, I can start using Bootstrap provided elements, like container and nav nav-tabs. From views/layouts/application:

# <!DOCTYPE html>
# <html>
# <head>
#    <title>Bloccit</title>
#    <%= stylesheet_link_tag    "application", :media => "all" %>
#    <%= javascript_include_tag "application" %>
#    <%= csrf_meta_tags %>
#  </head>
#  <body>
#    <div class="container">
#      <ul class="nav nav-tabs">
#        <li><%= link_to "Bloccit", welcome_index_path %></li>
#        <li><%= link_to "About", welcome_about_path %></li>
#      </ul>

#      <%= yield %>
#    </div>

#  </body>
#</html>

(Remove the CSS I put on the controller specific welcome.css.scss, as well as the HTML changes I made in index view.) Finally, do some blackbox Javascript stuff. In app/assets/javascripts/application.js:

//= require jquery
//= require jquery_ujs
//= require bootstrap
//= require_tree .

MODELS CHECKPOINT

Models are the classes in the application that we want to persist. So, for a reddit-style blog, you'll need Post and Comment classes. 

Models save and retrieve data from the database. So, a model usually represents a table in the database. A post model is going to be tied to a posts table in the database that includes things like the post's title & body. Models determine what information gets in/out of the database. 

Controllers should only handle requests – all of the 'business logic' should be in the models. 

Note: model is singular and table name is plural. 

Intermission: probably a decent idea to be working off branches in git:
## $ git checkout -b [branch name]

Before you create a model, think about what users need to do with it. For the Post model and corresponding database table, users need to be able to submit posts with titles and bodies (descriptions). 
## $ rails g model Post title:string body:text
      invoke  active_record
      create    db/migrate/20130430152108_create_posts.rb
      create    app/models/post.rb
Model generator did two things — built a migration file and a post.rb file. The post.rb file is the Post class (model). The migration file is everything we need to create a corresponding posts table in the database. 

We also coded what form the attributes will take — title is a string, body is text data. This is different than Ruby data types — string is a one-line Ruby string, text field is multi-line Ruby string. Can do same thing for comments:

## rails g model Comment body:text post:references
  invoke  active_record
      create    db/migrate/20130430152927_create_comments.rb
      create    app/models/comment.rb

  Every model in a Rails app gets an id attribute to uniquely identify it. To relate two models, you've got to exchange id's. The id of one model becomes a 'foreign key' when it's used as an attribute in another model. So, the Comment model needs to have an attribute named post_id; post_id attribute is there so that a comment can belong to a post. Multiple comments will have the same post_id. Because I include post:references when I ran the generator for the Comments model, it was already there. 

  If you check out the db/migrate files created, they'll look how you expect:

  # comments migration

class CreateComments < ActiveRecord::Migration
  def change
    create_table :comments do |t|
      t.text :body
      t.references :post

      t.timestamps
    end
    add_index :comments, :post_id
  end
end

When you $ rake db:migrate, it'll create these tables in the database. And, in corresponding models, you'll see the corresponding attributes:

class Post < ActiveRecord::Base
  attr_accessible :body, :title
end

Accessible attributes here are one's users can modify. I should modify it to explicate the relationships I want:

class Post < ActiveRecord::Base
  has_many :comments
  attr_accessible :body, :title
end

Similarly, in the Comments model, we see:

class Comment < ActiveRecord::Base
  belongs_to :post
  attr_accessible :body
end

(The belongs_to is already there because of the way I generated the model.)

RAILS CONSOLE CHECKPOINT

Rails console is the space within the terminal where I can execute code. It's the irb (the Ruby console) with the Rails environment loaded. Launch it once you're in App directory:

# $ rails c

I can do things like create database records from my terminal:

# > Post.create(title: "First post", body: "Body of first")

Post.create calls the create method on the Post class. Creates a new row in the database, and inserts what's passed as arguments into that row. 

Arguments passed were the title and body. Passed them as a Hash — keys are symbols corresponding to attribute names in the model, values are what I set the attributes to (passed as strings). 

This is what happens when we click submit on a post. 

Let's say I wanted to retrieve that row. 
# > p = _

This is shorthand — I assigned the variable 'p' to the last returned object in the console (basically, "_" is last returned object). 

So, if I go: 

# > p

I'll print the information associated with the row I just created. I can continue to manipulate this post: 

# p.comments.create(body: "First comment!")

Called the create method on the Comments class, for the post 'p.' So, console creates a comment row, populated with the post_id, which we extracted from the p variable. 

(This comments method was dynamically created by Rails because of has_many: comments in the Post model.)

Then, to print comments:

>p.comments

A lot of this is hinging on my models inheriting the methods from the class Active Record. If you look at the top of a model, you'll see:

# class Post < ActiveRecord::Base

Provides methods like create, as well as first. Within the console:

# > c = Comment.first

Assigned the first comment in the database to the variable 'c.' I can also use Ruby syntax in the console:

# > p.comments.each { |comment| p comment.body } 

I'm going to iterate over every comment instance for 'p' in the database, and call the method body on it (printing the body). 

SEED DATA CHECKPOINT

I don't want to manually seed a bunch of data in my development environment. It's nice to be able to just drop a large amount of data. 

Include Faker in my Gemfile:

# gem 'faker'

Make sure I'm in the app directory and then: 

# $ bundle install

Open up db/seeds.rb, remove all the commented lines. seeds.rb is a script that will seed my database. Then, add:

# require 'faker' 

#rand(10..30).times do
  # p = Post.create(title: Faker::Lorem.words(rand(1..10)).join(" "), body: Faker:Lorem.paragraphs(rand(1..4)).join("\n"))
  # rand(3..10).times do
  #   p.comments.create(body: Faker::Lorem.paragraphs(rand(1..2)).join("\n"))
  #  end
#end

#puts "Seed finished" 
#puts "#{Post.count} posts created"
#puts "#{Comment.count} comments created"

This is Ruby code. It's relying on the Faker API to call methods like 'words' and 'paragraphs.' Still using 'create' methods, but not passing explicit values — having the Faker module create the data. 

'rand' method runs a random number (designated by the range passed). The script then calls 'times' in order to call the create method that many times (rand provides the number for times). 

Within the command line I can run seeds.rb thusly: 
#$ rake db:seed

I can check around using the Active Record method find, again in the rails console (rails c)
#> p = Post.find(3)

The argument passed is the post ID. Can also check around with the count method: 
#> p.comments.count

CRUD

It's time to create some resources. A resource is a term that describes all of the components around an object. So, a Post resource in Bloccit will consist of a model, controller, views & routes. I've got the model, so time to create the posts_controller. Get onto a new git branch and: 

#$ rails g controller Posts index show new edit

I passed five arguments. First, the resource name (Posts). The generator method then created some stuff for all of the other arguments: 

#create  app/controllers/posts_controller.rb
#       route  get "posts/edit"
#       route  get "posts/new"
#       route  get "posts/show"
#       route  get "posts/index"
#      invoke  erb
#      create    app/views/posts
#      create    app/views/posts/index.html.erb
#      create    app/views/posts/show.html.erb
#      create    app/views/posts/new.html.erb
#      create    app/views/posts/edit.html.erb
#      invoke  helper
#      create    app/helpers/posts_helper.rb
#      invoke  assets
#      invoke    coffee
#      create      app/assets/javascripts/posts.js.coffee
#      invoke    scss
#      create      app/assets/stylesheets/posts.css.scss

And, if I look in routes.rb:

#Bloccit::Application.routes.draw do
#
#  get "posts/edit"
#  get "posts/new"
#  get "posts/show"
#  get "posts/index"

#  get "welcome/index"
#  get "welcome/about"

#  root :to => 'welcome#index'
#end

I'm going to replace these with more succinct code. I'll call the resources method, passing a symbol. When I do this, it'll tell Rails to create routes for every CRUD action. So, my new routes.rb file:

#Bloccit::Application.routes.draw do

#  resources :posts

#  match "about" => 'welcome#about', via: :get

#  root :to => 'welcome#index'
#end

If I run rake routes again:

    posts GET    /posts(.:format)          posts#index
          POST   /posts(.:format)          posts#create
 new_post GET    /posts/new(.:format)      posts#new
edit_post GET    /posts/:id/edit(.:format) posts#edit
     post GET    /posts/:id(.:format)      posts#show
          PUT    /posts/:id(.:format)      posts#update
          DELETE /posts/:id(.:format)      posts#destroy
    about GET    /about(.:format)          welcome#about
     root        /                         welcome#index


Ok, so what's CRUD? 

CRUD = create-read-update-delete. The actions are aligned with controller actions in a Rails app. Get = read, Post = create, Put = update, delete = delete. These routes exist for the Post object when I raked. These are all the types of Post requests a user can make. 

I changed the about and index paths, so I need to update my application layout: app/views/layouts/application.html.erb: 

#<li><%= link_to "Bloccit", root_path %></li>
#<li><%= link_to "About", about_path %> </li>

Ok, now I can start my rails and then plug: localhost:3000/posts into my browser. I can see the default HTML created by the controller generator. Now, how can I get it to show some real data? 

Go to app/controllers/posts_controller.rb. Where I was just looking, that's the index page. I know this because, from rake routes:

  posts GET    /posts(.:format)          posts#index

See how that is indicating localhost:3000/posts. If I want to show dynamic data, I've got to modify the index view in the posts_controller. 

# class PostsController < ApplicationController
# def index
#   @posts = Post.all
# end

I created an instance variable, and assigned it a collection of Post objects using the Active Record 'all' method. all returns an array of whatever I call it on (Post objects). 

If I create an instance variable in a controller method, I can use it in the associated view. Since @posts was created and assigned in the index method, I can use it in the index view. Clean out index.html.erb and:

#<h1>All Posts</h1>
#<% @posts.each do |post| %> 
#  <p><%= link_to post.title, post %></p>
#<% end %> 

Ok. So I've got the each method. Inside the each block, I create a link for each post instance. The arguments passed to link_to are built using the post instance (the block argument). Note that when an object, like the post instance, is passed to link_to (instead of a URL being passed), Rails will automatically extract the object id & use the class name to figure out the route to return. So, link_to returns this route: 

 post GET    /posts/:id(.:format)      posts#show

 This is a little 'Whoa.' 

 If I check out localhost:3000/posts, I'll see the data. Format is not good though. Clean it up with bootstrap. This is in the index view:

 # <h1>All Posts</h1>
#  <% @posts.each do |post| %> 
      <div class="media">
        <div class="media-body">
          <h4 class="media-heading">
            <%= link_to post.title, post %> 
          </h4>
        </div>
      </div>
    <% end %>

  Alright, if I click on a Post link, I get taken to a new view. Evaluating rake routes, it should be clear that this is the show view. This is still boilerplate HTML, so I've got to update the show method (in the posts_controller), and then the show view. 

  #def show
    @post = Post.find(params[:id])
  end

  The show method declares an instance variable named @post and assigns it to the retun of Post.find(params[:id]).

  I don't know what Post a user clicks on, so I can't some predict the ID. I have to get it from the request the user makes. Rails has a params hash that gets passed around on every request. It can be populated with different stuff, but in this case it's got my post id. I'm specifying the key of the hash (:id), and getting the value back (the actual post id). 

  Note — this isn't a collection, it's a single Post instance. Different than index method. 

  Ok, now fix the show view:

  # <h1><%= @post.title %></h1>
    <p><%= @post.body %></p>

    MORE CRUD

    So, posts can be viewed, but a user can't create them. I need to build a 'form' — a group of HTML elements that provide a place for a user to input data. 

    link_to is the helper method for generating HTML needed for a hyperlink; 
    In same way, form_for is going to generate the HTML needed for a form. 

    Ok, what's my form's purpose? Collect posts' title and body, submit to the server so it can be saved in database. Essentially, creating a new Post object. 

    First, I need a controller action. Open posts_controller and build a 'new' method. 

    def new
      @post = Post.new
    end

    Now I have an instance variable which is representing an empty Post object (Post.new). Now, I can access that on the related view (app/views/posts/new.html.erb) and add some code: 

<%= form_for @post do |f| %>
  <%= f.label :title %>
  <%= f.text_field :title %>

  <%= f.label :body %>
  <%= f.text_area :body %>

  <%= f.submit "Save" %>
<% end %>

But when I click Save? Unknown action — The action 'create' could not be found for PostsController. So, go do that: 

def create
  @post = Post.new(params[:post])
  if @post.save
    flash[:notice] = "Post was saved."
    redirect_to @post
  else
    flash[:error] = "There was an error saving the post. Please try again."
    render :new
  end
end

Notice here — "new" method just creates an empty instance of Post, which gets presented to the user on the app/views/posts/new.html.erb view. When the user clicks save, the "create" method is called, and either updates the database with the save method or returns an error. 

"create" does not have a corresponding view — there's nothing for the user to do/see. It's working to collect the data submitted and updata the database. 

Notice that params hash. Unlike in show, where the method used params to rab the value of an id, here the params hash is grabbing a value associated with the :post key. The value of the :post key is actually another hash, populated with the data submitted by the user in the form (the tital enad body fields). 

Once I assign @post with the value of params[:post], I call the 'save' method — an Active Record method that updates the database. Based on whether or not this works, I populate the flash hash with key :notice and the corresponding vale (a string that says whether or not everything got saved). 

Then, I called redirect_to, passing it the @post object. It extracts the id from @ post and builds the URL, sends me over there.

Now, I can do a little style work on the "New" view. 

app/views/posts/new.html.erb

<h1>New Post</h1>

<div class="row">
  <div class="span-6">
    <p>Guidelines for new posts:</p>
    <ul>
      <li>Make sure content is appropriate.</li>
      <li>Blah blah blah</li>
      <li>Blah blah blah</li>
      <li>Blah blah blah</li>
    </ul>
  </div>
  <div class="span-6">
    <%= form_for @post, html: { class: 'form-horizontal' } do |f| %>
      <div class="control-group">
        <%= f.label :title, class: 'control-label' %>
        <div class="controls">
          <%= f.text_field :title %>
        </div>
      </div>
      <div class="control-group">
        <%= f.label :body, class: 'control-label' %>
        <div class="controls">
          <%= f.text_area :body, rows: 8 %>
        </div>
      </div>
      <div class="control-group">
        <div class="controls">
          <%= f.submit "Save", class: 'btn' %>
        </div>
      </div>
    <% end %>
  </div>
</div>

New view corresponds to the 'create' action, Edit view corresponds to the 'update' action. I need to add edit and update to the posts_controller. 

def edit
    @post = Post.find(params[:id])
end

def update
  @post = Post.find(params[:id])
  if @post.update_attributes(params[:post])
    flash[:notice] = "Post was updated."
    redirect_to @post
  else
    flash[:error] = "There was an error saving the post. Please try again."
    render :new
  end
end

Very similar to new and create methods I just wrote. Now, I need to update the edit view to display a form. 

<h1>Edit Post</h1>
<div class="row">
  <div class="span-6">
    <p>Guidelines for new posts:</p>
    <ul>
      <li>Make sure content is appropriate.</li>
      <li>Blah blah blah</li>
      <li>Blah blah blah</li>
      <li>Blah blah blah</li>
    </ul>
  </div>
  <div class="span-6">
    <%= form_for @post, html: { class: 'form-horizontal' } do |f| %>
      <div class="control-group">
        <%= f.label :title, class: 'control-label' %>
        <div class="controls">
          <%= f.text_field :title %>
        </div>
      </div>
      <div class="control-group">
        <%= f.label :body, class: 'control-label' %>
        <div class="controls">
          <%= f.text_area :body, rows: 8 %>
        </div>
      </div>
      <div class="control-group">
        <div class="controls">
          <%= f.submit "Save", class: 'btn' %>
        </div>
      </div>
    <% end %>
  </div>
</div>

You probably want to edit from the 'show' page, so I can add a link there. 

<h1><%= @post.title %></h1>

<%= link_to "Edit", edit_post_path(@post), class: 'btn btn-mini' %>

<p><%= @post.body %></p>

Up to this point, my flash messages aren't actually working. I haven't included them in a view. Every view may need a flash message at some point, so it makes sense to put it in my unverisal spot — application.html.erb

app/views/layouts/application.html.erb and add: 

      <% if flash[:notice] %>
        <div class="alert alert-success">
          <button type="button" class="close" data-dismiss="alert">&times;</button>
          <%= flash[:notice] %>
        </div>
      <% elsif flash[:error] %>
        <div class="alert alert-error">
          <button type="button" class="close" data-dismiss="alert">&times;</button>
          <%= flash[:error] %>
        </div>
      <% elsif flash[:alert] %>
        <div class="alert">
          <button type="button" class="close" data-dismiss="alert">&times;</button>
          <%= flash[:alert] %>
        </div>
      <% end %>
